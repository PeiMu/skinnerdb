package joining.parallel.parallelization.hybrid;

import com.google.common.util.concurrent.AtomicDouble;
import joining.parallel.plan.LeftDeepPartitionPlan;
import joining.progress.State;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

/**
 * The plan information of the join plan
 * generated by search parallel threads.
 *
 * @author Anonymous
 */
public class HybridJoinPlan {
    /**
     * Finished join order.
     */
    public final int[] joinOrder;
    /**
     * Number of data parallel threads.
     */
    public final int nrThreads;
    /**
     * Finished split table.
     */
    public volatile int splitTable;
    /**
     * Progress for different tables.
     */
    public final AtomicDouble[][] progress;
    /**
     * States for different tables.
     */
    public final AtomicReference<State>[][] states;
    /**
     * The slowest state by comparing different split tables
     */
    public final AtomicReference<State>[] slowestStates;
    /**
     * The average reward of given join order.
     */
    public volatile double reward;
    /**
     * The average reward of given join order.
     */
    public volatile double firstReward;
    /**
     * Thread id of the join plan.
     */
    public final int tid;
    /**
     * Number of tables.
     */
    public final int nrTables;
    /**
     * Represents a left deep query plan
     */
    public final LeftDeepPartitionPlan plan;


    public HybridJoinPlan(int[] joinOrder, int nrThreads, int nrTables,
                          double reward, int tid, LeftDeepPartitionPlan plan) {
        this.joinOrder = joinOrder.clone();
        int nrForgets = 8;
        this.progress = new AtomicDouble[nrForgets][nrThreads * nrTables];
        this.states = new AtomicReference[nrForgets][nrThreads * nrTables];
        this.slowestStates = new AtomicReference[nrForgets];
        for (int forgetCtr = 0; forgetCtr < nrForgets; forgetCtr++) {
            for (int flagCtr = 0; flagCtr < nrThreads * nrTables; flagCtr++) {
                progress[forgetCtr][flagCtr] = new AtomicDouble(0);
                states[forgetCtr][flagCtr] = new AtomicReference<>(new State(nrTables));
            }
            this.slowestStates[forgetCtr] = new AtomicReference<>(new State(nrTables));
        }
        this.nrTables = nrTables;
        this.nrThreads = nrThreads;
        this.reward = reward;
        this.tid = tid;
        this.plan = plan;
    }

    @Override
    public String toString() {
        return "JoinPlan{" +
                "joinOrder=" + Arrays.toString(joinOrder) +
                ", splitTable=" + splitTable +
                ", reward=" + reward +
                '}';
    }
}
